//fastpassgen -f Grammer.fpg -o Parser.cs -n RockStarToCS.Parsing -t ParseNode -r root -at -s

using RockStarToCS.Parsing.ParseNodes

//root node
root => rstarprog => x[0] as ParseNode

//rockstar program
rstarprog => EOF => new ParseNodeList()
//just the one block allowed for now
rstarprog => blk => x[0] as ParseNode

//blocks
blk => stmtlst eline => x[0] as ParseNode

//statement list
stmtlst => stmtlst stmtlst => { var lst =x[0] as ParseNodeList; lst.Add(x[1] as ParseNode); return lst; }
stmtlst => stmt => new ParseNodeList(x[0] as ParseNode)

//statements
stmt => ass NL => x[0] as ParseNode
stmt => io NL => x[0] as ParseNode



//functions

//i/o
io => SAY var => new OutputParseNode(x[0] as Token, x[1] as ParseNode)
io => LSTN var => new InputParseNode(x[0] as Token, x[1] as VariableParseNode)

//assignments
ass => var IS NULL => new AssignmentParseNode(x[1] as Token, new NullParseNode(x[2] as Token), x[0] as VariableParseNode)
ass => var IS bool => new AssignmentParseNode(x[1] as Token, x[2] as ParseNode, x[0] as VariableParseNode)
ass => var IS wrdlst => new AssignmentParseNode(x[1] as Token, x[2] as ParseNode, x[0] as VariableParseNode)
ass => var IS STR => new AssignmentParseNode(x[1] as Token, new StringParseNode(x[2] as Token, (x[2] as Token).Value), x[0] as VariableParseNode)

//variables
var => CVARSP WORD => new VariableParseNode(x[0] as Token, (x[0] as Token).Value.ToLower() + " " + (x[1] as Token).Value, false)
var => PVAR => new VariableParseNode(x[0] as Token, (x[0] as Token).Value, true)
var => LVAR => new VariableParseNode(x[0] as Token)

//booleans
bool => TRUE => new BooleanParseNode(x[0] as Token)
bool => FALSE => new BooleanParseNode(x[0] as Token)

//word lists
wrdlst => wrdlst wrdlst => { var lst = x[0] as ParseNodeList; lst.Add(x[1] as ParseNode); return lst; }
wrdlst => wrd => new ParseNodeList(x[0] as ParseNode)

wrd => WORD => new WordParseNode(x[0] as Token)
wrd => CVARSP => new WordParseNode(x[0] as Token)

//empty line
//can match to a single empty line or many
eline => eline eline => { var lst = x[0] as ParseNodeList; lst.Add(x[1] as ParseNode); return lst; }
eline => ELINE => new EmptyLineParseNode(x[0] as Token)
eline => EOF => new EmptyLineParseNode(x[0] as Token)