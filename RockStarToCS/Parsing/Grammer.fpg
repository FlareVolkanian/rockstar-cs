//fastpassgen -f Grammer.fpg -o Parser.cs -n RockStarToCS.Parsing -t ParseNode -r root -at -s

using RockStarToCS.Parsing.ParseNodes

//root node
root => rstarprog => x[0] as ParseNode

//rockstar program
rstarprog => EOF => new ParseNodeList()
//just the one block allowed for now
rstarprog => blk => x[0] as ParseNode

//blocks
blk => stmtlst eline => x[0] as ParseNode

//statement list
stmtlst => stmtlst stmtlst => { var lst =x[0] as ParseNodeList; lst.Add(x[1] as ParseNode); return lst; }
stmtlst => stmt => new ParseNodeList(x[0] as ParseNode)

//statements
stmt => ass NL => x[0] as ParseNode
stmt => io NL => x[0] as ParseNode
stmt => incdec NL => x[0] as ParseNode
stmt => psla NL => x[0] as ParseNode
stmt => mult NL => x[0] as ParseNode


//functions

//i/o
io => SAY var => new OutputParseNode(x[0] as Token, x[1] as ParseNode)
io => LSTN var => new InputParseNode(x[0] as Token, x[1] as VariableParseNode)

//assignments
ass => var IS NULL => new AssignmentParseNode(x[1] as Token, new NullParseNode(x[2] as Token), x[0] as VariableParseNode)
ass => var IS bool => new AssignmentParseNode(x[1] as Token, x[2] as ParseNode, x[0] as VariableParseNode)
ass => var IS wrdlst => new AssignmentParseNode(x[1] as Token, x[2] as ParseNode, x[0] as VariableParseNode)
ass => var IS STR => new AssignmentParseNode(x[1] as Token, x[2] as StringParseNode, x[0] as VariableParseNode)

//variables
var => CVARSP WORD => new VariableParseNode(x[0] as Token, (x[0] as Token).Value.ToLower() + " " + (x[1] as Token).Value, false)
var => PVAR => new VariableParseNode(x[0] as Token, (x[0] as Token).Value, true)
var => LVAR => new VariableParseNode(x[0] as Token)

//poetic string literal assignment
psla => var SAYS wrdlst => new StringLiteralAssignmentParseNode(x[1] as Token, x[0] as VariableParseNode, x[2] as ParseNodeList)

//booleans
bool => TRUE => new BooleanParseNode(x[0] as Token)
bool => FALSE => new BooleanParseNode(x[0] as Token)

//increment/decrement
incdec => BLD var UP => new IncDecParseNode(x[0] as Token, x[1] as VariableParseNode, true)
incdec => KNK var DWN => new IncDecParseNode(x[0] as Token, x[1] as VariableParseNode, false)

//arithmetic
mult => add MULT mult => new MultiplyParseNode(x[1] as Token, x[0] as ParseNode, x[2] as ParseNode)
mult => add => x[0] as ParseNode
add => bool => x[0] as ParseNode
add => var => x[0] as ParseNode
add => str => x[0] as ParseNode

//word lists
wrdlst => wrdlst wrdlst => { var lst = x[0] as ParseNodeList; lst.Add(x[1] as ParseNode); return lst; }
wrdlst => wrd => new ParseNodeList(x[0] as ParseNode)

wrd => WORD => new WordParseNode(x[0] as Token)
wrd => CVARSP => new WordParseNode(x[0] as Token)

//empty line
//can match to a single empty line or many
eline => eline eline => { var lst = x[0] as ParseNodeList; lst.Add(x[1] as ParseNode); return lst; }
eline => ELINE => new EmptyLineParseNode(x[0] as Token)
eline => EOF => new EmptyLineParseNode(x[0] as Token)

//strings
str => STR => new StringParseNode(x[0] as Token, (x[0] as Token).Value)